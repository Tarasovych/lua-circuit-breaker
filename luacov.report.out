==============================================================================
src/breaker.lua
==============================================================================
    2 local Counters = require "lua-circuit-breaker.counters"
    2 local errors = require "lua-circuit-breaker.errors"
    2 local oop = require "lua-circuit-breaker.oop"
    2 local CircuitBreaker = oop.class()
      local debug_log

    2 local states = {
    2 	closed = "closed",
    2 	open = "open",
    2 	half_open = "half_open"
      }

    2 function CircuitBreaker:__new(settings) -- luacheck: ignore 561
   12 	debug_log = settings.notify
   12 	settings = settings or {}
   12 	local expiry = (settings.now or os.time)() + settings.interval

   12 	return {
   12 		_half_open_max_calls_in_window = settings.half_open_max_calls_in_window,
   12 		_half_open_timeout = settings.half_open_timeout or 120,
   12 		_open_timeout = settings.open_timeout or 60,
   12 		_interval = settings.interval or 0,
   12 		_min_calls_in_window = settings.min_calls_in_window,
   12 		_closed_to_open = settings.closed_to_open or
      			function(counters)
 1000 				return counters:total_samples() >= settings.min_calls_in_window and
 1000 					(counters.total_failures / counters:total_samples()) * 100 >= settings.failure_percent_threshold
      			end,
   12 		_half_open_to_close = settings.half_open_to_close or
      			function(counters)
  180 				return counters:total_samples() >= settings.half_open_min_calls_in_window and
  180 					(counters.total_failures / counters:total_samples()) * 100 < settings.failure_percent_threshold
      			end,
   12 		_half_open_to_open = settings.half_open_to_open or
      			function(counters)
  180 				return counters:total_samples() >= settings.half_open_min_calls_in_window and
  180 					(counters.total_failures / counters:total_samples()) * 100 >= settings.failure_percent_threshold
      			end,
   12 		_is_successful = settings.is_successful or function(val)
****0 				return val
      			end,
   12 		_error = settings.error or function(err)
****0 				return nil, err
      			end,
   12 		_rethrow = settings.rethrow or error,
   12 		_now = settings.now or os.time,
   12 		_notify = settings.notify,
   12 		_state = states.closed,
   12 		_counters = Counters(),
   12 		_generation = 0,
   12 		_expiry = expiry,
   12 		_last_state_notified = true,
   12 		_version = settings.version,
   12 	}
      end

    2 function CircuitBreaker:state()
****0 	self:_update_state()
****0 	return self._state
      end

    2 function CircuitBreaker:_before()
 1887 	self:_update_state()
 1887 	if self._state == states.open then
    3 		return false, errors.open
 1884 	elseif self._state == states.half_open and self._counters.requests >= self._half_open_max_calls_in_window then
    1 		return false, errors.too_many_requests
      	end
 1883 	self._counters:_on_request()

 1883 	return true
      end

    2 function CircuitBreaker:_after(previous_generation, is_success)
 1796 	self:_update_state()

 1796 	if self._generation ~= previous_generation then
****0 		return
      	end

 1796 	if is_success then
  684 		self:_on_success()
      	else
 1112 		self:_on_failure()
      	end
      end

    2 function CircuitBreaker:_update_state()
      	-- If window has not expired
 3683 	if (self._expiry > self._now()) then
 3676 		return
      	end

    7 	if self._state == states.closed then
    1 		self:_next_generation()
    6 	elseif self._state == states.half_open then
    1 		self:_set_state(states.closed)
    1 		debug_log("Transition: Half Open to Closed, timeout")
      	else
    5 		debug_log("Transition: Open to Half Open")
    5 		self:_set_state(states.half_open)
      	end
      end

    2 function CircuitBreaker:_on_success()
  684 	self._counters:_on_success()
      	-- Todo: change state in half-open state when minimum calls in window to calculate % are elapsed
  684 	if self._state == states.half_open then
   71 		if self._half_open_to_close(self._counters) then
    1 			self:_set_state(states.closed)
      		end
   71 		if self._half_open_to_open(self._counters) then
****0 			self:_set_state(states.open)
      		end
      	end
      end

    2 function CircuitBreaker:_on_failure()
 1112 	self._counters:_on_failure()
 1112 	if self._state == states.closed and self._closed_to_open(self._counters) then
    8 		debug_log("Transition: Close to Open")
    8 		self:_set_state(states.open)
      	end
      	-- Change state in half-open state when minimum calls in window to calculate % are elapsed
 1112 	if self._state == states.half_open then
  109 		if self._half_open_to_close(self._counters) then
****0 			debug_log("Transition: Half Open to Close")
****0 			self:_set_state(states.closed)
      		end
  109 		if self._half_open_to_open(self._counters) then
    1 			debug_log("Transition: Half Open to Open")
    1 			self:_set_state(states.open)
      		end
      	end
      end

    2 function CircuitBreaker:_set_state(new_state)
   16 	self._state = new_state
   16 	self._last_state_notified = false
   16 	self:_next_generation()
   16 	self:_notify(new_state, print)
      end

    2 function CircuitBreaker:_next_generation()
   17 	self._generation = self._generation + 1
   17 	self._counters = Counters()
   17 	self._expiry = 0

   17 	if self._state == states.open then
    9 		self._expiry = self._now() + self._open_timeout
    8 	elseif self._state == states.half_open then
    5 		self._expiry = self._now() + self._half_open_timeout
      	else
    3 		self._expiry = self._now() + self._interval
      	end
      end

    2 return {
    2 	new = CircuitBreaker,
    2 	states = states
    2 }

==============================================================================
src/counters.lua
==============================================================================
    1 local oop = require "oop"

    1 local Counters = oop.class()

    1 function Counters:__new()
   29 	return {
   29 		requests = 0,
   29 		total_successes = 0,
   29 		total_failures = 0,
   29 		consecutive_successes = 0,
   29 		consecutive_failures = 0
   29 	}
      end

    1 function Counters:total_samples()
 1538 	return self.total_successes + self.total_failures
      end

    1 function Counters:_on_request()
 1883 	self.requests = self.requests + 1
      end

    1 function Counters:_on_success()
  684 	self.total_successes = self.total_successes + 1
  684 	self.consecutive_successes = self.consecutive_successes + 1
  684 	self.consecutive_failures = 0
      end

    1 function Counters:_on_failure()
 1112 	self.total_failures = self.total_failures + 1
 1112 	self.consecutive_failures = self.consecutive_failures + 1
 1112 	self.consecutive_successes = 0
      end

    1 return Counters

==============================================================================
src/errors.lua
==============================================================================
    1 local _M = {
    1 	open = "Circuit Breaker is open so request was terminated",
    1 	too_many_requests = "Circuit Breaker reports too many requests in half open state"
      }

    1 return _M

==============================================================================
src/factory.lua
==============================================================================
    1 local breaker = require "breaker"
    1 local utils = require "utils"

      --[[ 
        Structure of Breaker_factory object will be like
          {
              group_1 = {
                  name_1 = cb_object_1,
                  name_2 = cb_object_2,
              },
              group_2 = {
                  name_3 = cb_object_3,
                  name_4 = cb_object_4,
              },
          }
      --]]

    1 local Breaker_factory = {}

    1 function Breaker_factory:new(obj)
   11     obj = obj or {}

          -- https://stackoverflow.com/a/6863008
          -- This line will make o inherit all methods of Breaker_factory.
   11     setmetatable(obj, self)
   11     self.__index = self
   11     return obj
      end

    1 function Breaker_factory:remove_circuit_breaker(name, group)
****0     local group_not_exists = self:check_group(group)
****0     if group_not_exists then
****0         return false
          end

****0     self[group][name] = nil
****0     return true
      end

    1 function Breaker_factory:remove_breakers_by_group(group)
****0     self[group] = nil
****0     return true
      end

    1 function Breaker_factory:get_circuit_breaker(name, group, conf)
 1887     if name == nil or name == "" then
****0         return nil, "Cannot get circuit breaker without a name"
          end
          
 1887     if group == nil or group == "" then
****0         group = name
          end

 1887     local group_not_exists = self:check_group(group)
 1887     if group_not_exists then
   11         self[group] = {}
          end

          -- Update CB object if a CB object is requested with new version of settings
 1887     if self[group][name] == nil or (self[group][name] ~= nil and self[group][name]._version < conf.version) then
   12         local settings = utils.prepare_settings(conf)
   12         self[group][name] = breaker.new(settings)
          end

 1887     return self[group][name], nil
      end

    1 function Breaker_factory:check_group(group)
 1887     if self[group] == nil then
   11         return "Trying to access invalid group in circuit breaker factory object: " .. group
          end
      end

    1 return Breaker_factory

==============================================================================
src/oop.lua
==============================================================================
    2 local metaclass = {}

    2 function metaclass:__call(...)
   42     return setmetatable(self:__new(...), self)
      end

      local function class(prototype)
    4     prototype = prototype or {}
    4     prototype.__index = prototype
    4     return setmetatable(prototype, metaclass)
      end

    2 return {
    2     class = class,
    2 }

==============================================================================
src/utils.lua
==============================================================================
      local function prepare_settings(settings)
      	-- TODO: add settings validations
   12 	return {
   13 		name = settings.name,
   13 		interval = settings.window_time,
   17 		open_timeout = settings.wait_duration_in_open_state,
   16 		half_open_timeout = settings.wait_duration_in_half_open_state,
   16 		min_calls_in_window = settings.min_calls_in_window,
   12 		failure_percent_threshold = settings.failure_percent_threshold,
   12 		half_open_min_calls_in_window = settings.half_open_min_calls_in_window,
   13 		half_open_max_calls_in_window = settings.half_open_max_calls_in_window,
   12 		notify = settings.notify or function(state)
****0         	print(string.format("Breaker %s state changed to: %s", state._state))
          	end,  
   12 		half_open_to_open = settings.half_open_to_open,
   12 		half_open_to_close = settings.half_open_to_close,
   12 		closed_to_open = settings.closed_to_open,
   12 		version = settings.version,
   12 		now = settings.now,
   12 	}
      end

    1 return {
    1 	prepare_settings = prepare_settings
    1 }

==============================================================================
Summary
==============================================================================

File             Hits Missed Coverage
-------------------------------------
src/breaker.lua  98   8      92.45%
src/counters.lua 23   0      100.00%
src/errors.lua   4    0      100.00%
src/factory.lua  24   9      72.73%
src/oop.lua      9    0      100.00%
src/utils.lua    19   1      95.00%
-------------------------------------
Total            177  18     90.77%
